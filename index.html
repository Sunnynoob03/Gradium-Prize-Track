<!DOCTYPE html>
<html>
<head>
  <title>ASL Recognition + TTS</title>
  <style>
    video, canvas { 
      position: absolute; 
      left: 0; 
      top: 0; 
      transform: scaleX(-1);
    }

    #prediction {
      position: absolute;
      top: 20px;
      right: 20px;
      font-size: 72px;
      color: red;
      font-weight: bold;
      text-shadow: 2px 2px 4px black;
    }

    #word {
      position: absolute;
      bottom: 20px;
      left: 20px;
      font-size: 48px;
      color: white;
      text-shadow: 2px 2px 4px black;
    }

    #speakBtn {
      position: absolute;
      bottom: 80px;
      left: 20px;
      font-size: 24px;
      padding: 10px 20px;
    }
  </style>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
</head>

<body>
  <video class="input_video" autoplay></video>
  <canvas class="output_canvas" width="640" height="480"></canvas>

  <div id="prediction">?</div>
  <div id="word"></div>

  <button id="speakBtn">Speak</button>

  <script>
    let word = "";

    // ⭐ Backend TTS function (calls Flask, not Gradium directly)
    async function speakText(text) {
      try {
        const response = await fetch("http://127.0.0.1:5000/tts", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ text: text })
        });

        const data = await response.json();

        if (!data.audio) {
          console.error("No audio returned:", data);
          return;
        }

        const audio = new Audio("data:audio/mp3;base64," + data.audio);
        await audio.play();

      } catch (err) {
        console.error("TTS error:", err);
      }
    }

  async function getData() {
      try {
          const response = await fetch("http://127.0.0.1:5000/get_word");
          
          if (!response.ok) {
              throw new Error("Network response was not ok");
          }

          const data = await response.json();
          console.log("GET result:", data);
          return data;

      } catch (err) {
          console.error("GET request failed:", err);
      }
  }
   async function speakGradium(text) {
    try {
        const response = await fetch("https://us.api.gradium.ai/api/post/speech/tts", {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "x-api-key": "gsk_c8272c96c679370b7b933839604c3e943cabea8299e010e13f210a944a0ac23a" // MAKE SURE NOT TO LEAK THIS!!!!!! AND PUT IN A DIFFERENT FILE
            },
            body: JSON.stringify({
                voice_id: "YTpq7expH9539ERJ",   // working voice
                output_format: "wav",
                text: text,
                json_config: "{}",
                only_audio: true
            })
        });

        if (!response.ok) {
            console.error("Gradium error:", await response.text());
            return;
        }

        const data = await response.arrayBuffer()

        // Create a Blob for the WAV audio
        const audioBlob = new Blob([data], { type: "audio/wav" });

        // Create a temporary URL for the audio
        const audioUrl = URL.createObjectURL(audioBlob);

        // Play it
        const audio = new Audio(audioUrl);
        audio.play();

    } catch (err) {
        console.error("TTS request failed:", err);
    }
} 

    // ⭐ Speak button
    document.getElementById("speakBtn").addEventListener("click", () => {
      if (word.length > 0) {
        text = getData()["word"]; // TODO: YOU ACTUALLY SEND THE WORD TO THE BACKEND
        text = document.getElementById("word").innerText;
        // text = "Hello world!" // GET RID OF THIS
        speakGradium(text);
      }
    });

    // ⭐ Crash-proof sendLandmarks
    async function sendLandmarks(landmarks) {
      if (!landmarks || landmarks.length === 0) return;

      const flat = [];
      for (let i = 0; i < landmarks.length; i++) {
        flat.push(landmarks[i].x, landmarks[i].y, landmarks[i].z);
      }

      try {
        const response = await fetch("http://127.0.0.1:5000/predict", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ landmarks: flat })
        });

        const result = await response.json();

        if (result.prediction) {
          const letter = result.prediction;
          document.getElementById("prediction").innerText = letter;

          word += letter;
          document.getElementById("word").innerText = word;
        }
      } catch (err) {
        console.error("Prediction error:", err);
      }
    }

    // ⭐ MediaPipe setup
    const hands = new Hands({
      locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
      }
    });

    hands.setOptions({
      maxNumHands: 1,
      modelComplexity: 1,
      minDetectionConfidence: 0.7,
      minTrackingConfidence: 0.7
    });

    hands.onResults((results) => {
      const canvasElement = document.querySelector('.output_canvas');
      const canvasCtx = canvasElement.getContext('2d');

      canvasCtx.save();
      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

      if (results.multiHandLandmarks) {
        const landmarks = results.multiHandLandmarks[0];

        drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS);
        drawLandmarks(canvasCtx, landmarks);

        sendLandmarks(landmarks);
      }

      canvasCtx.restore();
    });

    // ⭐ Camera setup
    const videoElement = document.querySelector('.input_video');
    const camera = new Camera(videoElement, {
      onFrame: async () => {
        await hands.send({ image: videoElement });
      },
      width: 640,
      height: 480
    });

    camera.start();
  </script>
</body>
</html>